def _astar(self, cid: int, safe: np.ndarray,
           start: Tuple[int, int, int], goal: Tuple[int, int, int],
           start_tangent=None, goal_tangent=None,
           tangent_penalty_weight=5.0, boundary_penalty_weight=5):

    from scipy.spatial import cKDTree
    import numpy as np
    import heapq

    MAX_X, MAX_Y, MAX_Z = safe.shape

    def make_key(x, y, z, dir_id):
        return (((x * MAX_Y + y) * MAX_Z + z) * 32 + (dir_id if dir_id is not None else 0))

    openh = []
    openg = {}
    closed = set()

    s = Node(start, parent=None, dir_id=None)
    s.g = 0.0
    s.h = heuristic(start, goal)
    s.f = s.h
    heapq.heappush(openh, (s.f, s))
    openg[make_key(*start, None)] = s.f

    shape = safe.shape

    # ---- planning grid & KDTree ----
    planning_grid = getattr(self, "planning_voxel_grid", None)
    planning_min_index = np.asarray(self.voxelization.planning_min_index, dtype=float)
    planning_origin_world = np.asarray(self.voxelization.planning_voxel_origin, dtype=float)
    if planning_grid is not None:
        planning_true_voxels = np.argwhere(planning_grid)
        planning_kdtree = cKDTree(planning_true_voxels) if len(planning_true_voxels) > 0 else None
    else:
        planning_kdtree = None

    def planning_idx_to_world(pidx):
        p = np.asarray(pidx, dtype=float)
        return planning_origin_world + (planning_min_index + p) * self.voxel_size

    def world_to_orig_voxel(world_pt):
        return tuple(self.voxelization.convert_point_to_voxel(np.asarray(world_pt, dtype=float)).astype(int))

    def orig_voxel_to_world(orig_vox):
        return np.asarray(self.voxelization.min_bound, dtype=float) + np.asarray(orig_vox,
                                                                                 dtype=float) * self.voxel_size

    def line_collision_free(orig_a, orig_b, obstacle_voxel):
        a_w = orig_voxel_to_world(orig_a)
        b_w = orig_voxel_to_world(orig_b)
        vec = b_w - a_w
        L = np.linalg.norm(vec)
        if L <= 0:
            ai = np.round(orig_a).astype(int)
            if (ai < 0).any() or ai[0] >= obstacle_voxel.shape[0] or ai[1] >= obstacle_voxel.shape[1] or ai[2] >= \
                    obstacle_voxel.shape[2]:
                return False
            return not bool(obstacle_voxel[ai[0], ai[1], ai[2]])
        steps = max(2, int(L / (self.voxel_size * 0.5)))
        for t in np.linspace(0.0, 1.0, steps + 1):
            p = a_w + t * vec
            pi = np.asarray(self.voxelization.convert_point_to_voxel(p), dtype=int)
            if (pi < 0).any() or pi[0] >= obstacle_voxel.shape[0] or pi[1] >= obstacle_voxel.shape[1] or pi[2] >= \
                    obstacle_voxel.shape[2]:
                return False
            if obstacle_voxel[pi[0], pi[1], pi[2]]:
                return False
        return True

    def avail(x, y, z):
        x, y, z = int(x), int(y), int(z)
        # 越界判断 safe
        if not (0 <= x < safe.shape[0] and 0 <= y < safe.shape[1] and 0 <= z < safe.shape[2]):
            return False
        # safe 占据直接不可走
        if safe[x, y, z]:
            return False
        # planning_grid 判断
        if planning_grid is not None:
            idx = np.array([x, y, z], dtype=float) - planning_min_index
            idx = np.round(idx).astype(int)
            if np.any(idx < 0) or np.any(idx >= planning_grid.shape):
                return False
            if not planning_grid[tuple(idx)]:
                return False
        return True

    unit_dirs = self.unit_vectors
    id2dir = self.id2dir
    cos_table = self.cos_table
    axis_penalty = self._compute_axis_turn_penalty
    angle_penalty = self._compute_turn_penalty
    z_penalty = self.z_penalty
    turn_penalty = self.turn_penalty
    min_cos_threshold = 0.25
    max_jump_dist = 10  # 最大跳跃 voxel 数量

    # ---- 找离散栅格邻居函数 ----
    def find_nearest_planning_voxel(pt):
        if planning_kdtree is None:
            return []
        idx_est = (np.array(pt) - planning_origin_world) / self.voxel_size - planning_min_index
        idx_est = np.round(idx_est).astype(int)
        dist, ids = planning_kdtree.query(idx_est, k=min(10, len(planning_true_voxels)))
        if np.isscalar(ids):
            ids = [ids]
        candidates = []
        for i in ids:
            pidx = planning_true_voxels[i]
            world_candidate = planning_idx_to_world(pidx)
            orig_candidate = np.array(world_to_orig_voxel(world_candidate))
            if line_collision_free(world_to_orig_voxel(pt), orig_candidate, safe):
                candidates.append(tuple(pidx))
        return candidates

    start_candidates = find_nearest_planning_voxel(start)
    goal_candidates = find_nearest_planning_voxel(goal)
    if len(start_candidates) == 0:
        start_candidates = [tuple(start)]
    if len(goal_candidates) == 0:
        goal_candidates = [tuple(goal)]

    # ---- A* 主循环 ----
    while openh:
        _, cur = heapq.heappop(openh)
        cx, cy, cz = cur.pos
        key = make_key(cx, cy, cz, cur.dir_id)
        if key in closed:
            continue

        # 到达 goal_candidates
        if any(cur.pos == g for g in goal_candidates):
            path = []
            node = cur
            while node:
                path.append(node.pos)
                node = node.parent
            path.reverse()
            return path, np.zeros(3, dtype=float)

        closed.add(key)

        # ---- 26 邻居筛选 + KDTree 跳跃 ----
        trend_vec = np.array(goal) - np.array(cur.pos)
        trend_vec = trend_vec / (np.linalg.norm(trend_vec) + 1e-6)
        candidate_neighbors = []

        for dir_id, d_unit in enumerate(unit_dirs):
            if cur.dir_vec is not None:
                cos_dir = cur.dir_vec @ d_unit
                if cos_dir < min_cos_threshold:
                    continue

            nx, ny, nz = np.array(cur.pos) + d_unit
            nx, ny, nz = int(round(nx)), int(round(ny)), int(round(nz))
            if avail(nx, ny, nz):
                candidate_neighbors.append((tuple([nx, ny, nz]), dir_id, d_unit))

        # 如果没有邻居或走向不理想 → KDTree 跳跃
        if not candidate_neighbors and planning_kdtree is not None:
            dist, idx = planning_kdtree.query(np.array(cur.pos), k=min(10, len(planning_true_voxels)))
            if np.isscalar(idx):
                idx = [idx]
            for i in idx:
                pidx = planning_true_voxels[i]
                jump_vec = np.array(pidx) - np.array(cur.pos)
                jump_vec_norm = jump_vec / (np.linalg.norm(jump_vec) + 1e-6)
                if np.dot(trend_vec, jump_vec_norm) < 0.5:  # 趋势方向筛选
                    continue
                # 插入中间节点
                steps = int(np.linalg.norm(jump_vec))
                if steps == 0:
                    continue
                path_segment = [tuple(np.round(np.array(cur.pos) + jump_vec * t / steps).astype(int)) for t in range(1, steps + 1)]
                # 检查连续性
                if all(avail(*p) for p in path_segment):
                    candidate_neighbors.append((tuple(pidx), None, jump_vec_norm))
                    break  # 只取最近一个有效 jump

        # ---- 更新邻居节点 ----
        for next_pos, dir_id, d_unit in candidate_neighbors:
            gnew = cur.g + 1.0
            if cur.dir_vec is not None and d_unit is not None:
                gnew += tangent_penalty_weight * (1 - np.dot(cur.dir_vec, d_unit))
            if cur.parent is None and start_tangent is not None and d_unit is not None:
                gnew += boundary_penalty_weight * (1.0 - (start_tangent @ d_unit))
            if self.is_close(next_pos, goal) and goal_tangent is not None and d_unit is not None:
                gnew += boundary_penalty_weight * (1.0 - (goal_tangent @ d_unit))

            hnew = heuristic(next_pos, goal)
            fnew = gnew + hnew
            state_key = make_key(*next_pos, dir_id)
            if state_key not in openg or fnew < openg[state_key]:
                node = Node(next_pos, parent=cur, dir_id=dir_id, dir_vec=d_unit)
                node.g, node.h, node.f = gnew, hnew, fnew
                openg[state_key] = fnew
                heapq.heappush(openh, (fnew, node))
                print(f"[Step] {cur.pos} -> {next_pos} ({'safe neighbor' if avail(*next_pos) else 'jump KDTree'})")

    return []  # 无路径